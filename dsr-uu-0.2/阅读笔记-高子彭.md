注：Opt Data Len = n*4 + 2
initiator, Address[1], Address[2], ..., Address[n], target

8.1.1 当打包一个使用DSR协议的数据包的时候，必须遵守以下这几步规则：
1. 在路由缓存中搜索在这个数据包头部中的目的地址。
2. 如果没有找到到达目的地址的路由，就启动路由寻找机制来寻找到达目的地址的路由（下一节将会介绍），为此目标节点地址启动路由发现会导致节点在此现有数据包的DSR选项标头中添加路由请求选项，或者将此现有数据包保存到其发送缓冲区，并通过发送包含路由请求选项的单独数据包来启动路由发现。如果节点选择通过向现有数据包添加路由请求选项来启动路由发现，那么它将使用IP“有限广播”地址（255.255.255.255）替换IP目标地址字段，并且复制原始IP目标 添加到新数据包的Route Request选项的Target Address字段的地址。
3. 如果数据包现在不包含路由请求选项，则此节点必须具有到数据包的目标地址的路由; 如果节点有多个到此目标地址的路由，则该节点选择一个用于传送此数据包。 如果此路由的长度大于1跳，或者节点确定从该路由中的第一跳节点请求DSR网络层确认，则将DSR选项头插入数据包，如第8.1.2节所述，并插入DSR源路由选项，如第8.1.3节所述。 数据包中的源路由从所选路由初始化为数据包的目标地址。
4. 将数据包传输到选定源路由中给出的第一跳节点地址，并且使用路由维护确定下一跳的可达性。

8.1.2 将DSR选项添加到包的头部
如果需要，发起分组的节点将DSR选项头添加到分组，以携带路由协议所需的信息。 数据包绝不能包含多个DSR选项头。 通过执行以下操作将DSR选项头添加到数据包，（假定这个数据包不包含必须放在DSR选项头部之前的其他协议的头部选项）：
1. DSR选项的首部必须放在IP首部之后其他协议首部之前
2. 将DSR Options首部的Next Header字段设置为数据包IP首部的Protocol number字段。
3. 将数据包的IP首部的Protocol字段设置为DSR协议的号码（已分配好）

8.1.3 将DSR源路由选项添加至数据包
如果需要，发起分组的节点将DSR源路由选项添加到分组，以便将源路由从该始发节点传送到分组的最终目的地地址。具体来说，添加DSR源路由选项的节点构造DSR源路由选项，并根据以下步骤序列修改IP数据包：
1. 节点新建一个DSR源路由选项并且将其添加到DSR首部选项后
2. 包含路由选项n的Address[i]的数量是分组的源路由中中间节点的数量。DSR源路由选项中的Segments Left字段初始化为n。
3. 将源路由中的IP地址复制到DSR源路由选项中的Addres[i]序列中

8.1.4 处理一个接收到的数据包
不论是转发还是窃听还是作为目的节点，一个节点在收到一个包含DSR选项的首部数据包时，该节点必须处理这个数据包：
1. 当一个节点接收到一个包含路由请求的选项的数据包时，该节点应该从这个请求包中提取出源路由并且将该条路由消息添加到路由缓存中，路由信息包含一系列的节点地址，如
initiator, Address[1], Address[2], ..., Address[n]
此时的initiator是IP首部中的源地址
2. 当一个节点接收到一个包含路由回复的选项的数据包时，该节点应该从这个请求包中提取出源路由并且将该条路由消息添加到路由缓存中，路由信息包含一系列的节点地址，如
initiator, Address[1], Address[2], ..., Address[n]
此时的initiator是IP首部中的目的地址；具体处理过程在8.2.6
3. 当一个节点接收到一个包含路由错误的选项的数据包时，具体处理过程在8.3.5 
4. 当一个节点接收到一个ACK选项的数据包时；具体处理过程在8.3.3
5. 当一个节点接收到一个ACK请求（Acknowledgement Request）选项的数据包时；具体处理过程在8.3.3
6. 当一个节点接收到一个ACK（Acknowledgement）选项的数据包时；具体处理过程在8.3.3
7. 当一个节点接收到一个DSR源路由选项的数据包时，具体处理在8.1.5

8.1.5 处理接收到的DSR源路由选项
当一个节点接收到一个DSR源路由选项的数据包时，该节点应该检查是否有机会自动缩短路由，具体过程如下：
1. 该节点在无条件路由回复表中查找是否存在一个目的地址为收到的数据包的源IP地址的表项，如果存在的话比较这两个过程所经历过的路径是否相同，如果不同，则更新路由表中的路由信息，将其更新为这个新的路径过程。
2. 如果找不到这个这个表项的话，就新建一个表项，存入该条路由信息，并将Timeout初始化为GratReplyHoldoff。如果有一次路由超时的话，就删除该表项
3. 如果同一个数据包接收到多次，则丢弃该数据包
如果数据包未作为上述自动路由缩短的一部分而被丢弃，则节点必须按照以下步骤顺序处理源路由选项：
3. 如果Segments Left字段的值为0，那么节点删除该数据包的首部
4. 否则的话，设置n=（Opt Data Len - 2) / 4.
5. 如果Segments Left字段的值大于n，就发送一个ICMP数据包给源节点，指出这个Segments Left字段值
6. 否则，将Segments Left字段的值递减1.让i等于n减去Segments Left。 这是地址向量中要访问的下一个地址的索引。
7. 如果Address [i]或IP目标地址是多播地址，则丢弃该数据包。 不要进一步处理DSR源路由选项。
8. 如果此节点发送的数据包大小超过MTU，则丢弃并向源节点发送一个ICMP报文或者对该数据宝进行分片处理
9. 在转发数据包时，通过验证下一跳节点是否可达，对数据包的下一跳执行路由维护8.3.

8.1.6 处理未知的DSR选项

8.2 路由发现

路由发现是S节点向目的节点D发送数据包，但是还没获取具体的路由时启动的路由寻找的过程。
这个路由发现过程完全是按需进行的，且不依赖于任何节点处的网络协议栈中任何层的路由信息​​或邻居节点检测的任何周期性的或后台的数据交换。
路由发现过程使用两种类型的消息：路由请求和路由应答，以主动在ad hoc网络搜索出到达目的节点的路由。
路由发现仅在源节点有数据包需要发送到目的地且没有有效的路由时使用，如果对一个节点的路由请求没有得到回复，那么对这个节点的路由请求的间隔应该加倍，且不超过（MaxRequestPeriod）。

8.2.1 发起路由请求
某个发起路由发现的节点在IP首部中初始化路由请求选项。 这可以是一个空的IP数据包，仅用于携带此路由请求选项，节点也可以在其需要发送到目标节点的某些现有数据包中包含路由请求选项。路由请求选项必须包含在数据包的DSR选项头中。 要初始化Route Request选项，节点将执行以下步骤：
1. 将Option Type字段设置为2
2. 将Opt Data Len字段设置为6，路由请求选项的首部大小初始化是8，Opt Data Len字段排除Option Type和Opt Data Len字段本身的大小。
3. 必须将Identification 字段必须设置为一个新值以区分于该节点发出的其他路由请求消息，
4. 将Target Address字段设置为路由发现的目的节点的地址。

IP首部的源地址设置为该节点自己的IP地址，目的地址设置为广播。

每个节点必须维护自己的路由请求表，该表存储了该节点发起的路由请求信息，当发起一个新的路由请求时，该节点必须参考已经记录在路由请求表中的信息，在其发起路由请求后也必须更新路由请求表的信息，以便下一个路由请求参考。具体过程如下：

1. 目标节点的路由请求表条目记录了该节点为该目标节点发起的最后一次路由发现的路由请求的IP头中使用的Time-to-Live (TTL)字段。该值允许该节点实现各种算法，以控制其路由请求在为目标发起的每个路由发现上的传播。
2. 目标节点的路由请求表条目记录了路由请求的次数，以及距离下一次路由请求的剩余时间。
3. 每个节点必须根据路由请求表内的条目来实现Back-off算法以及确定启动新的路由发现的速率（加倍发送间隔）。
 
8.2.2 处理收到的路由请求包

当一个节点收到路由请求包时，此节点必须对该路由请求包进行处理，具体的处理过程如下：
1. 如果该节点为是路由请求包中的目的节点，那么该节点应当回复一个路由应答包给请求方，并且停止转发，具体过程见8.2.4
2. 如果该节点不是路由请求的目的节点，该节点需要检查该数据包所经过的节点IP以确定该数据包是否是自己发出的数据包，或者是自己已经转发过的数据包。如果是的话，该节点将会丢弃该数据包。
3. 否则，如果该数据包是通过需要双向链路进行单播传输的网络接口所接收到。则该节点需要检查该路由请求是否由其黑名单上的节点所发送，如果是且单向链路状态是“可能的”，则丢弃该数据包。
4. 否则，如果该数据包是通过需要双向链路进行单播传输的网络接口所接收到。则该节点需要检查该路由请求是否由其黑名单上的节点所发送，如果是且单向链路状态是“有问题的”，则丢弃该数据包。
5. 否则 该节点必须在路由请求表中查找一个来自发起方的路由请求信息，如果在表中找到这样的条目，则节点必须在该表条目中搜索最近接收的路由请求的标识值的高速缓存，以确定与该路由中的标识值和目标节点地址匹配的高速缓存中是否存在条目。 请求。 如果在路由请求表中的此条目中的此高速缓存中找到这样的（标识，目标地址）条目，则节点必须丢弃带有路由请求选项的整个数据包。
6. 否则，该节点需要再进一步处理该条路由请求：
6.1 在此最近收到的路由请求的（标识，目标地址）值的缓存中添加此路径请求的条目。
6.2 创建整个数据包的副本，并在数据包副本上执行以下步骤。
6.3 将此节点自己的IP地址附加到数据包中的Address [i]值列表，并将Route Request中的Opt Data Len字段的值增加4（IP地址的大小）。 但是，如果该节点有多个网络接口，则必须通过sec：multiple中指定的特殊处理修改此步骤。
6.4 该节点应该在其自己的路由缓存中搜索到该路由请求的目标的路由（从其自身，就好像它是数据包的源）。 如果在路由缓存中找到这样的路由，则该节点应该按照8.2.3节中概述的过程向该路由请求的发起者返回“缓存的路由回复”，如果在那里指定的限制允许的话。
6.5 如果该节点没有收到路由应答，则该节点应该将该数据包副本作为链路层广播再次发送，在发送广播之前具有短的抖动延迟。 抖动周期应该选择为随机周期，均匀分布在0和BroadcastJitter之间。

8.2.3 通过路由缓存生成路由回复

当一个节点收到路由请求数据包时，如果该节点在其路由缓存中具有从其自身到该目标的路由，则该节点可以避免将路由请求进一步广播。节点从其自己的缓存路由到路由请求目标生成的这种路由回复称为“Cache Route Replay（缓存路由回复）”，这种机制可以通过减少路由泛滥来大大降低网络上路由发现的总体开销。接收的路由请求的一般处理过程在8.2.2节中描述;此部分指定在生成和返回Cache Route Reply之前必须满足的附加要求，并指定返回Cache Route Reply的过程。
在为此路由请求生成缓存路由应答之前，节点必须验证在路由请求中累积的路由中没有列出重复地址以及来自此节点的路由缓存的路由。具体来说，以下地址之间必须没有重复：


8.2.4 发起路由回复

8.2.5 防止路由回复风暴

8.2.6 处理收到的路由回复